Основы интегрирования
=====================

> Оригинал статьи: https://gafferongames.com/post/integration_basics


Введение
--------

Привет, добро пожаловать в [**игровую физику**](https://gafferongames.com/categories/game-physics/),
меня зовут [Гленн Фидлер](https://gafferongames.com/).

Если вы когда-нибудь интересовались, как происходит симуляция физики
в видеоиграх, эта серия статей поможет вам разобраться. Я предполагаю, что вы
понимаете C++ и уже знаете азы физики и математики. Если вы будете внимательно
разбирать предложенные примеры, то вам не понадобится ничего, кроме этих
базовых знаний.

В сущности, физическая симуляция — это множество маленьких предсказаний,
основанных на законах физики. Эти предсказания очень просты и фактически
сводятся к утверждениям вроде «сейчас тело находится здесь и движется с такой-то
скоростью в этом направлении, значит через короткий промежуток времени оно
должно оказаться здесь.» Математическая техника, осуществляющая такие
предсказания, называется __интегрированием__.

Вопрос о том, как именно реализуется интегрирование, и является предметом данной
статьи.


Интегрирование уравнений движения
---------------------------------

Наверное, вы помните из школьного или университетского курса физики, что сила
равна ускорению, умноженному на массу:
```math
F = m a
```

Если перенести *m* в другую часть уравнения, можно увидеть, что ускорение —
это сила, поделенная на массу. Это соотносится с интуитивным пониманием, что
более тяжёлый объект труднее сдвинуть с места.

```math
a = \frac{F}{m}
```

Ускорение — это прирост (величина изменения) скорости относительно времени:
![dv/dt = a = F/m](img/eq03.png)
```math
\frac{dv}{dt} = a = \frac{F}{m}
```

Точно так же, скорость — это изменение положения (координаты) относительно
времени:
```math
\frac{dx}{dt} = v
```

Это означает, что если нам известно текущее положение и скорость тела, а также
силы, приложенные к нему, мы можем проинтегрировать эти уравнения, чтобы
найти его положение и скорость в какой-либо будущий момент времени.    


Численное интегрирование
------------------------

Если вы не изучали дифференциальное исчисление в университете, не отчаивайтесь:
вы всё равно почти в таком же хорошем положении, как и другие читатели. Дело
в том, что мы не собираемся решать эти уравнения аналитически, как это делается
на первом курсе. Вместо этого мы найдём решение с помощью __численного
интегрирования__.

Вот как оно работает. Мы начинаем с исходным положением и скоростью, затем
продвигаемся на небольшой шаг вперёд, чтобы определить скорость и положение
в следующий момент. Повторяем так снова и снова, каждый раз продвигаясь
на небольшую величину по времени, используя результат предыдущего расчёта как
начальную точку для следующего.

Но как нам вычислить изменение скорости и положения на каждом шагу?

На помощь приходят __уравнения движения__.

Обозначим текущий момент времени $t$, а временной шаг $dt$ (сокращение для
_delta time_; буквой «дельта» в математике обозначают прирост или изменение,
а _time_ означает просто «время»).

Теперь можно записать уравнения движения в очевидной форме.

```
ускорение = сила / масса
изменение координаты = скорость * dt
изменение скорости = ускорение * dt
```

Интуитивно понятно, что если машина движется со скоростью 60 километров в час,
то через 1 час она будет находиться на 60 км дальше по дороге. А если она
ускоряется на 10 км/ч каждую секунду, то её скорость возрастёт на 100 км/ч
через 10 секунд. 

Разумеется, эти рассуждения применимы только тогда, когда скорость и ускорение
постоянны. Но даже если нет, мы располагаем неплохой аппроксимацией,
от которой можно отталкиваться.

Переведём теперь формулы в код. Возьмём неподвижный предмет весом 1 кг и
приложим к нему постоянную силу в 10 Н. Размер шага по времени пусть будет 1 с.

```c++
double t = 0.0;
float dt = 1.0f;

float velocity = 0.0f;  // скорость
float position = 0.0f;  // координата
float force = 10.0f;    // сила
float mass = 1.0f;      // масса

while ( t <= 10.0 )
{
    position = position + velocity * dt;
    velocity = velocity + ( force / mass ) * dt;
    t += dt;
}
```

Вот результаты:
```
        Положение         Скорость
        --------------    --------------
t=0:    position = 0      velocity = 0
t=1:    position = 0      velocity = 10
t=2:    position = 10     velocity = 20
t=3:    position = 30     velocity = 30
t=4:    position = 60     velocity = 40
t=5:    position = 100    velocity = 50
t=6:    position = 150    velocity = 60
t=7:    position = 210    velocity = 70
t=8:    position = 280    velocity = 80
t=9:    position = 360    velocity = 90
t=10:   position = 450    velocity = 100
```

Как видите, мы на каждом шаге знаем как положение, так и скорость тела. Это
и есть численное интегрирование.


Явный метод Эйлера
------------------

Тот тип интегрирования, который мы применили только что, называется __явным
методом Эйлера__. 

Чтобы вы не попали впросак, я сразу скажу, что несмотря на написание,
это фамилия должна произноситься как *Ои-ла(р)* (хотя в реальной жизни все
носители русского языка всё равно произносят её именно так, как она пишется).
Речь идёт о швейцарском математике [Леонарде Эйлере](https://ru.wikipedia.org/Эйлер,_Леонард)
(Leonhard Euler), который и изобрёл данный метод.

Интегрирование Эйлера — самый базовый метод численного интегрирования. Он
обеспечивает 100%-ю точность только в том случае, когда скорость изменения 
интегрируемой величины постоянна относительно времени.

Поскольку в примере выше ускорение является константой, скорость (интеграл
ускорения) вычисляется без ошибок. Однако мы также интегрируем эту скорость,
чтобы найти положение тела, и она у нас меняется из-за ускорения. Таким
образом, получаем неточность в координате. 

Насколько велика эта неточность? Давайте выясним!

Существует выражение, описывающие движение тела под действием постоянного
ускорения в замкнутой форме. Воспользуемся им, чтобы сравнить наше численное
решение с точным результатом:
```math
s &= u t + 0.5 a t^2 = \\
  &= 0.0 t + 0.5 a t^2 = \\
  &= 0.5 \cdot 10 \cdot 10^2 = \\
  &= 0.5 \cdot 10 \cdot 100 = \\
  &= 500. 
```

В действительности за 10 секунд предмет переместится на 500 метров, хотя явный
метод Эйлера говорит, что только на 450 метров. Погрешность в 50 метров за 10
секунд!

Звучит очень, очень плохо. Правда, в действительности игровые движки не имеют
дела с таким большим временным шагом. Обычно шаг интегрирования соответствует
частоте кадров.

Интегрирование с $dt = 1/100$ даёт гораздо лучший результат:
```
            Положение                 Скорость
            ---------------------     --------------------
t=9.90:     position = 489.552155     velocity = 98.999062
t=9.91:     position = 490.542145     velocity = 99.099060
t=9.92:     position = 491.533142     velocity = 99.199059
t=9.93:     position = 492.525146     velocity = 99.299057
t=9.94:     position = 493.518127     velocity = 99.399055
t=9.95:     position = 494.512115     velocity = 99.499054
t=9.96:     position = 495.507111     velocity = 99.599052
t=9.97:     position = 496.503113     velocity = 99.699051
t=9.98:     position = 497.500092     velocity = 99.799049
t=9.99:     position = 498.498077     velocity = 99.899048
t=10.00:    position = 499.497070     velocity = 99.999046
```

Теперь, как видим, точность вполне приемлема. Вполне приемлема для видеоигры,
конечно.


Почему метод Эйлера (может быть) не так уж хорош
------------------------------------------------

Взяв достаточно малый шаг интегрирования, мы можем заставить явный метод Эйлера
обеспечить достойный результат при постоянном ускорении. Но что делать, когда
ускорение не константа?

Хороший пример системы с переменным ускорением — [грузик на пружинке](https://ccrma.stanford.edu/CCRMA/Courses/152/vibrating_systems.html).

В этой системе точечная масса прикреплена к концу пружины, и её движение гасится
какой-либо разновидностью трения. На тело (грузик) действуют две силы: одна, 
пропорциональная расстоянию до точки покоя, тянет его к этой точке, а другая,
пропорциональная скорости тела, но направленная в противоположную сторону,
замедляет его движение.

Здесь ускорение, очевидно, не постоянно, а изменяется как непрерывная функция
положения и скорости тела, которые сами, в свою очередь, меняются непрерывно
с течением времени.

Эта система — пример [затухающего гармонического осциллятора](https://ru.wikipedia.org/wiki/Гармонический_осциллятор#Свободные_колебания_гармонического_осциллятора_с_затуханием),
хорошо изученной задачи, для которой найдено аналитическое решение. С этим
решением можно сравнить результат численного интегрирования, чтобы проверить
последний.

Рассмотрим для начала систему с медленным затуханием, где грузик колеблется
вокруг положения равновесия, постепенно теряя скорость. Пусть у неё будут такие
параметры:

```
Масса: 1 кг
Начальное положение: 1000 м от точки покоя
Коэффициент упругости: k = 15 Н/м
Коэффициент трения: b = 0.1 Н·с/м
```

Вот график точного решения:
![Затухающие колебания](https://gafferongames.com/img/game-physics/integration_basics_damped_exact_solution.png)

А вот результат интегрирования по явному методу Эйлера (график сжат по
вертикали, чтобы поместиться в границы рисунка):
![Взрыв погрешности](https://gafferongames.com/img/game-physics/integration_basics_damped_explicit_euler.png)

> Мне не удалось воспроизвести результат, когда система идёт вразнос, поэтому я
> просто вставлю в статью картинки из оригинала. Надеюсь, они никуда не денутся.
> — *прим. перев.*

Вместо того, чтобы затухать и сходиться к положению равновесия, колебания
наращивают свою амлитуду!

Наша система неустойчива при интегрировании явным методом Эйлера с $dt = 1/100$.

К сожалению, мы уже интегрируем с достаточно малым шагом, и потому у нас нет
практичеких вариантов повышения точности. Да и как бы мы ни уменьшали шаг,
всегда можно подобрать такое значение параметра жесткости $k$, которое приведёт
к подобному поведению.


Полунеявный метод Эйлера
------------------------

Следующий интегратор, который мы рассмотрим, называется [полунеявным методом
Эйлера](https://en.wikipedia.org/wiki/Semi-implicit_Euler_method). 

Большинство промышленных игровых движков задействуют именно его.

Перейти от явной схемы Эйлера к полунеявной очень просто. Достаточно лишь
переставить местами следующие две строчки:
```c++
position += velocity * dt;
velocity += acceleration * dt;
```
чтобы получилось вот это:
```c++
velocity += acceleration * dt;
position += velocity * dt;
```

Применение полунеявного метода Эйлера с $dt = 1/100$ к модели пружинного
маяника даёт стабильный результат, очень похожий на точное решение:
![Затухающие колебания](https://gafferongames.com/img/game-physics/integration_basics_damped_semi_implicit_euler.png)

Хотя полунеявный метод Эйлера имеет тот же порядок погрешности, что и явный
(а именно, порядок 1), при интегрировании уравнений движения он даёт лучший
результат, поскольку является [симплектическим](https://en.wikipedia.org/wiki/Symplectic_integrator). 


Есть много разных численных интеграторов
----------------------------------------

[Неявный метод Эйлера](http://web.mit.edu/10.001/Web/Course_Notes/Differential_Equations_Notes/node3.html)
хорошо подходит для решения жёстких дифференциальных уравнений, демонстрирующих
неустойчивость при симуляции другими методами. Его недостаток заключается
в необходимости решения системы уравнений на каждой итерации.

[Метод Верле](https://ru.wikipedia.org/wiki/Метод_Стёрмера_—_Верле) предлагает
ещё большую точность, чем неявный метод Эйлера и требует меньше памяти в случае
большого числа частиц. Это симплектический метод второго порядка.

Имеется также целое семейство __методов Рунге–Кутты__. В него входит как уже
знакомый нам явный метод Эйлера, так и интеграторы более высоких порядков,
наиболее классическим из которых является схема Рунге–Кутты четвёртого порядка,
или просто __RK4__.

> Дальше автор посвящает целый абзац правильному произношению фамилий
> [Карла Рунге](https://ru.wikipedia.org/wiki/Рунге,_Карл) и
> [Мартина Кутты](https://ru.wikipedia.org/wiki/Кутта,_Мартин_Вильгельм),
> который я, пожалуй, оставлю за скобками. Лучше бы он столько внимания уделял
> выводу формул, честное слово. — *прим. перев.*

Интегратор RK4 имеет порядок 4, что означает, что накопленная погрешность имеет
порядок четвёртой производной[^1]. Это делает метод чрезвычайно точным. Куда
более точным, чем явный и неявный методы Эйлера, который имеют порядок 1. 

[^1]: Так у автора: «…on the order of the fourth derivative.» На самом деле,
производная тут ни при чём, накопленная погрешность определяется шагом
интегрирования $dt$, в случае метода порядка 4 она составляет $O(dt^4)$.
— *прим. перев.*

Однако большая точность не означает автоматически, что RK4 — «самый лучший»
интегратор, или даже что он лучше, чем полунеявный метод Эйлера. Всё гораздо
сложнее.

В любом случае, это интересный алгоритм и вполне достойный объект для изучения.


Реализация RK4
--------------

В сети можно найти множество прекрасных объяснений математики, стоящей за
методом Рунге–Кутты. Вот только несколько примеров: [раз](https://ru.wikipedia.org/wiki/Метод_Рунге_—_Кутты),
[два](http://web.mit.edu/10.001/Web/Course_Notes/Differential_Equations_Notes/node5.html),
[три](https://www.researchgate.net/publication/49587610_A_Simplified_Derivation_and_Analysis_of_Fourth_Order_Runge_Kutta_Method).
Настоятельно советую вам проследить, откуда берутся соответствующие формулы и
как они работают на математическом уровне. А я сам, исходя из того, что целевой
аудиторией моей статьи являются программисты, а не математики, сосредоточусь
на программной реализации. Поехали!

Во-первых, введём структуру, описывающую состояние системы, чтобы скорость
и положение тела можно было с удобством держать рядом друг с другом:
```c++
struct State
{
    float x;      // положение
    float v;      // скорость
};
```

Нам также пригодится структура, хранящая производные от этих величин:
```c++
struct Derivative
{
    float dx;      // dx/dt = скорость
    float dv;      // dv/dt = ускорение
};
```

Далее, определим функцию, которая будет переносить физическое состояние от
момента $t$ к моменту $t + dt$ и затем пересчитывать производные в новом
состоянии:
```c++
Derivative evaluate( const State & initial, 
                     double t, 
                     float dt, 
                     const Derivative & d )
{
    State state;
    state.x = initial.x + d.dx*dt;
    state.v = initial.v + d.dv*dt;

    Derivative output;
    output.dx = state.v;
    output.dv = acceleration( state, t+dt );
    return output;
}
```

Функция ускорения (`acceleration`) приводит в действие всю симуляцию.
Обратившись снова к модели пружинного маятника и положив массу равной единице,
будем возвращать из функции его ускорение:
```c++
float acceleration( const State & state, double t )
{
    const float k = 15.0f;
    const float b = 0.1f;
    return -k * state.x - b * state.v;
}
```

Наконец, мы добрались и до самой процедуры интегрирования по схеме RK4:
```c++
void integrate( State & state, 
                double t, 
                float dt )
{
    Derivative a,b,c,d;

    a = evaluate( state, t, 0.0f, Derivative() );
    b = evaluate( state, t, dt*0.5f, a );
    c = evaluate( state, t, dt*0.5f, b );
    d = evaluate( state, t, dt, c );

    float dxdt = 1.0f / 6.0f * 
        ( a.dx + 2.0f * ( b.dx + c.dx ) + d.dx );
    
    float dvdt = 1.0f / 6.0f * 
        ( a.dv + 2.0f * ( b.dv + c.dv ) + d.dv );

    state.x = state.x + dxdt * dt;
    state.v = state.v + dvdt * dt;
}
```

Интегратор RK4 вычисляет производные в четырёх точках, чтобы определить кривизну
линии графика. Обратите внимание, как производная `a` используется, чтобы
рассчитать производную `b`, чтобы затем из `b` рассчитать `c`, а из неё, в свою
очередь, `d`. Именно наличие отзвука текущей производной в последующей и есть
то, что обеспечивает методу Рунге–Кутты его точность.

Что важно, все производные `a`, `b`, `c` и `d` будет *различными* в случае,
когда их изменение зависит от времени или от состояния системы. Например,
как у нашего пружинного маятника: ускорение — функция текущего положения
и скорости, и они меняются с течением времени.

Когда все четыре производные найдены, мы берём их взвешенное среднее,
определяя таким образом наилучшую производную. Оптимальные веса выводятся из
разложения в [ряд Тейлора](https://ru.wikipedia.org/wiki/Ряд_Тейлора). Далее
эта комбинированная производная используется, чтобы обновить положение
и скорость тела так же, как в обычном методе Эйлера.



Эйлер против Рунге и Кутты
--------------------------

Ладно, теперь перейдём к тестам интегратора RK4.

Так как он использует схему более высокого порядка (4-го, а не 1-го), он покажет
заметно более точный результат, чем полунеявный метод Эйлера, правда же?

![Все три графика совпадают](https://gafferongames.com/img/game-physics/integration_basics_damped_rk4_vs_semi_implicit_euler.png)

**Нет.** Оба метода настолько точны, что увидеть какую-либо разницу
невооруженным глазом просто невозможно. Оба метода устойчивы и очень хорошо
следуют точному решению с шагом $dt = 1/100$.

![Графики почти совпадают](https://gafferongames.com/img/game-physics/integration_basics_damped_rk4_vs_semi_implicit_euler_zoomed_in.png)

Сильно увеличив график, можно подтвердить, что RK4 *действительно* немного
точнее, чем полунеявный метод Эйлера. Но стоит ли такое улучшение затраченных
на него вычислительных ресурсов? Трудно сказать.

Давайте попристальнее поищем разницу в поведении этих двух интеграторов.
К сожалению, мы не можем рассмотреть систему на больших масштабах времени,
поскольку её колебания слишком быстро затухают до нуля. Поэтому переключимся на
модель [простого гармонического осциллятора](https://ru.wikipedia.org/wiki/Гармонический_осциллятор#Простое_гармоническое_движение),
который может вечно совершать неослабевающие колебания.

Вот точный результат, к которому мы стремимся:
![Незатухающая синусоида](https://gafferongames.com/img/game-physics/integration_basics_undamped_exact_solution.png)

Чтобы ещё больше усложнить жизнь нашим конкурсантам, увеличим временной шаг
до 0.1 с.

Теперь запустим интегрирование на отрезке в 90 секунд и приблизим график:
![](https://gafferongames.com/img/game-physics/integration_basics_undamped_rk4_vs_semi_implicit_euler.png)

За 90 секунд полунеявный метод Эйлера (оранжевая кривая) резошёлся по фазе
с точным решением (синяя кривая) из-за небольшого несоответствия частоты.
А Рунге–Кутта (зелёная кривая) имеет правильную частоту, но зато теряет энергию!

Эффект становится заметнее, если повысить шаг до 0.25 с.

RK4 держит частоту, но теряет энергию:
![](https://gafferongames.com/img/game-physics/integration_basics_undamped_rk4_5fps.png)

Эйлер лучше справляется с сохранением энергии в среднем, но плывет по фазе:
![](https://gafferongames.com/img/game-physics/integration_basics_undamped_semi_implicit_euler_5fps.png)

Какой интересный результат! Теперь понятно, что нельзя просто заявить, что RK4
имеет более высокий порядок и поэтому «лучше». В этом вопросе много нюансов.


Заключение
----------

Какую схему интегрирования выбрать для вашей видеоигры?

Я рекомендую **полунеявный метод Эйлера**. Простой и дешёвый, и при том куда
более устойчивый, чем явный метод Эйлера, он позволяет поддерживать выполнение
закона сохранения энергии, даже оказываясь близко к пределу своих возможностей.

Если вам не хватает точности полунеявного метода Эйлера, обратите внимание
на [симплектические интеграторы](https://en.wikipedia.org/wiki/Symplectic_integrator)
более высокого порядка, разработанные специально для [гамильтоновых систем](https://ru.wikipedia.org/wiki/Гамильтонова_система).
Возможно, вы найдёте более современную технику интегрирования, которая в вашем
случае подойдет лучше, чем RK4.

И наконец, если в вашем коде все ещё встречается вот это…:
```c++
position += velocity * dt;
velocity += acceleration * dt;
```
…найдите минутку, чтобы переписать этот кусок так:
```c++
velocity += acceleration * dt;
position += velocity * dt;
```

Обещаю, что результат вам понравится! :)
